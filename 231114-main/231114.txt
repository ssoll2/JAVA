변수타입: 자료형: 다형성 --> 조상님을 따른다. 상속을 받으면
buyer.buy(new Video()); // 객체를 매개변수 타입을 넣는다.
buyer.buy(new Audio()); // 객체타입의 변수의 값을 출력

오버라이딩: 조상의 메서드를 나의 방식을 재구현

객체지향: 다형성 -> 진짜 중요하다.

@추상클래스: 
일반 클래스와 동일하다 -> 추상메서드를 정의해서 사용한다.
추상메서드를 추상클래스에서 선언하면 무조선 자식 메서드에서 오버라이딩 해야한다.
추상클래스: 추상 메서드가 항상 존재한다.(X)
abstract	   멤버변수와 생성자를 사용할 수 있다.(O)
	   추상메서드 선언부에 선언했다.
	   추상클래스를 상속받는 클래스는 무조건 오버라이딩 한다.(O)

@인터페이스: 추상메서드랑 상수만 선언할 수 있다. ( 애플리케이션의 이미지는 선언부), 앨레베이터의 버튼은 인터페이스)
인터페이스는 클래스가 아니고, 스스로 객체를 생성할 수 없다. 구현된 것이 없는 설계도
어떤 형태로도 객체를 만들 수 없기 때문에 클래스라고 부를 수 없다.
인터페이스는 필드와 생성자를 가질 수 없고, 오직 추상메서드와 상수만 포함된다.
interface 인터페이스 이름{
	public static final 타입 상수이름 = 값;
	public abstract 메서드 이름(매개변수 목록);
}
1) 추상메서드 집합이라서 추상클래스보다 추상화가 높다.
2) 인터페이스 모든 멤버는 public이다.(접근 제어자 낮은 단계)
   public static final -> 명시안해도 자동 인식한다.(자동적 컴파일)

@인터페이스 구현/다형성 사용방법 
1) 인터페이스 정의된 추상메서드를 완성하며 인터페이스 자체의 추상메서드를 구현해줄 클래스를 작성해야 한다.
부모 인터페이스: 메서드를 모두 사용하지 않을 경우
자식 클래스: abstract 꼭 정의한다.

2) 인터페이스: 다중 상속이 가능하다.(선언부만 존재하기 때문)
*클래스는 단일 상속: 부모의 메서드를 상속받는데 메서드는 구현부가 존재한다.
메서드가 동일할 경우는 구현부가 다르기 때문에 자식이 어떤 걸 선택할 지 모른다.

3) 인터페이스는 다형성이 가능하다.
인터페이스 부모역할도 할 수 있다.
* 자식 클래스 메서드를 만들고 리턴타입으로 부모형(인터페이스) 반환가능하다.
main static : Fightable f = new Fighter(); // 자식객체
Fightable 클래스 메서드를 이용해서 반환가능(Fightable method() { return f;}

Q. 추상클래스 인터페이스 공통점?
- 미완성 설계도이고 추상메서드를 가지고 있다.
(모듈화: 독립적인 구현 사용 가능, 객체변경이 필요할 때 수정이 최소화
정보은닉: 실제 구현 클래스 내용보지 않아도 개발 코드 객체 사용
추상화: 더 생각해서 만들어야 하는 부분)

Q. 추상클래스 인터페이스 차이점?
- 인터페이스 IV(인스턴스 멤버:변수/메서드)를 가질 수 없다.
(인터페이스는 추상화가 심화된 상황이며 구현될 수 없고 추상메서드로 캡슐화를 사용한다.)


@다중 인터페이스 구현
[접근제한자] class 클래스 이름 implements 인터페이스1, 인터페이스2{
	//필드변수
	//생성자
	//인터페이스 1 메서드(추상 오버라이딩=구현한다.)
	//인터페이스 2 메서드(추상 오버라이딩=구현한다.)
}
1) 인터페이스 각기능들을 따로 선언하고 자식들에게 다중 상속한다.

@인터페이스 상속
[접근제한자]  interface 인터페이스 이름 extends 인터페이스 1, 인터페이스2{
	// 추상메서드
}

@인터페이스 장점





























